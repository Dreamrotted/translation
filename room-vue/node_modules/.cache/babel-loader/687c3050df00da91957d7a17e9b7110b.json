{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTransition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\nvar TRANSITION_NONE = 0;\nvar TRANSITION_P2C = 1;\nvar TRANSITION_C2P = 2;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\n\nfunction getDimension(data, visualDimension) {\n  var dimensions = data.dimensions;\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n\n    if (dimInfo && dimInfo.otherDims[visualDimension] === 0) {\n      return dimensions[i];\n    }\n  }\n} // get value by dimension. (only get value of itemGroupId or childGroupId, so convert it to string)\n\n\nfunction getValueByDimension(data, dataIndex, dimension) {\n  var dimInfo = data.getDimensionInfo(dimension);\n  var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n\n  if (dimInfo) {\n    var value = data.get(dimInfo.name, dataIndex);\n\n    if (dimOrdinalMeta) {\n      return dimOrdinalMeta.categories[value] || value + '';\n    }\n\n    return value + '';\n  }\n}\n\nfunction getGroupId(data, dataIndex, dataGroupId, isChild) {\n  // try to get groupId from encode\n  var visualDimension = isChild ? 'itemChildGroupId' : 'itemGroupId';\n  var groupIdDim = getDimension(data, visualDimension);\n\n  if (groupIdDim) {\n    var groupId = getValueByDimension(data, dataIndex, groupIdDim);\n    return groupId;\n  } // try to get groupId from raw data item\n\n\n  var rawDataItem = data.getRawDataItem(dataIndex);\n  var property = isChild ? 'childGroupId' : 'groupId';\n\n  if (rawDataItem && rawDataItem[property]) {\n    return rawDataItem[property] + '';\n  } // fallback\n\n\n  if (isChild) {\n    return;\n  } // try to use series.dataGroupId as groupId, otherwise use dataItem's id as groupId\n\n\n  return dataGroupId || data.getId(dataIndex);\n} // flatten all data items from different serieses into one arrary\n\n\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n    var dataGroupId = seriesInfo.dataGroupId;\n\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n\n      return;\n    }\n\n    var indices = data.getIndices();\n\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        data: data,\n        groupId: getGroupId(data, dataIndex, dataGroupId, false),\n        childGroupId: getGroupId(data, dataIndex, dataGroupId, true),\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\n\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\n\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\n\nfunction stopAnimation(el) {\n  el.stopAnimation();\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\n\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\n\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        ? extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n\n  var hasMorphAnimation = false;\n  /**\n   * With groupId and childGroupId, we can build parent-child relationships between dataItems.\n   * However, we should mind the parent-child \"direction\" between old and new options.\n   *\n   * For example, suppose we have two dataItems from two series.data:\n   *\n   * dataA: [                          dataB: [\n   *   {                                 {\n   *     value: 5,                         value: 3,\n   *     groupId: 'creatures',             groupId: 'animals',\n   *     childGroupId: 'animals'           childGroupId: 'dogs'\n   *   },                                },\n   *   ...                               ...\n   * ]                                 ]\n   *\n   * where dataA is belong to optionA and dataB is belong to optionB.\n   *\n   * When we `setOption(optionB)` from optionA, we choose childGroupId of dataItemA and groupId of\n   * dataItemB as keys so the two keys are matched (both are 'animals'), then universalTransition\n   * will work. This derection is \"parent -> child\".\n   *\n   * If we `setOption(optionA)` from optionB, we also choose groupId of dataItemB and childGroupId\n   * of dataItemA as keys and universalTransition will work. This derection is \"child -> parent\".\n   *\n   * If there is no childGroupId specified, which means no multiLevelDrillDown/Up is needed and no\n   * parent-child relationship exists. This direction is \"none\".\n   *\n   * So we need to know whether to use groupId or childGroupId as the key when we call the keyGetter\n   * functions. Thus, we need to decide the direction first.\n   *\n   * The rule is:\n   *\n   * if (all childGroupIds in oldDiffItems and all groupIds in newDiffItems have common value) {\n   *   direction = 'parent -> child';\n   * } else if (all groupIds in oldDiffItems and all childGroupIds in newDiffItems have common value) {\n   *   direction = 'child -> parent';\n   * } else {\n   *   direction = 'none';\n   * }\n   */\n\n  var direction = TRANSITION_NONE; // find all groupIds and childGroupIds from oldDiffItems\n\n  var oldGroupIds = createHashMap();\n  var oldChildGroupIds = createHashMap();\n  oldDiffItems.forEach(function (item) {\n    item.groupId && oldGroupIds.set(item.groupId, true);\n    item.childGroupId && oldChildGroupIds.set(item.childGroupId, true);\n  }); // traverse newDiffItems and decide the direction according to the rule\n\n  for (var i = 0; i < newDiffItems.length; i++) {\n    var newGroupId = newDiffItems[i].groupId;\n\n    if (oldChildGroupIds.get(newGroupId)) {\n      direction = TRANSITION_P2C;\n      break;\n    }\n\n    var newChildGroupId = newDiffItems[i].childGroupId;\n\n    if (newChildGroupId && oldGroupIds.get(newChildGroupId)) {\n      direction = TRANSITION_C2P;\n      break;\n    }\n  }\n\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex; // TODO if specified dim\n\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      }\n\n      if (isOld) {\n        return direction === TRANSITION_P2C ? diffItem.childGroupId : diffItem.groupId;\n      } else {\n        return direction === TRANSITION_C2P ? diffItem.childGroupId : diffItem.groupId;\n      }\n    };\n  } // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n\n\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel; // TODO Mark this elements is morphed and don't morph them anymore\n\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex); // Can't handle same elements.\n\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n\n    if ( // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }\n\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n\n    if (newEl) {\n      stopAnimation(newEl);\n\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex); // We can't use the elements that already being morphed\n\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n\n  return seriesKey;\n}\n\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n\n  return seriesKey;\n}\n\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\n\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap(); // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldDataGroupId = globalStore.oldDataGroupIds[idx];\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, {\n      dataGroupId: oldDataGroupId,\n      data: oldData\n    });\n\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          key: transitionKeyStr,\n          dataGroupId: oldDataGroupId,\n          data: oldData\n        });\n      });\n    }\n  });\n\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newDataGroupId = series.get('dataGroupId');\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey); // Only transition between series with same id.\n\n      var oldData = oldDataMap.get(transitionKeyStr); // string transition key is the best match.\n\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        } // TODO check if data is same?\n\n\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            dataGroupId: oldData.dataGroupId,\n            divide: getDivideShapeFromData(oldData.data),\n            data: oldData.data\n          }],\n          newSeries: [{\n            dataGroupId: newDataGroupId,\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        // e.g. 'female', 'male' -> ['female', 'male']\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n\n            if (oldData.data) {\n              oldSeries_1.push({\n                dataGroupId: oldData.dataGroupId,\n                divide: getDivideShapeFromData(oldData.data),\n                data: oldData.data\n              });\n            }\n          });\n\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                dataGroupId: newDataGroupId,\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          // e.g. ['female', 'male'] -> 'female', 'male'\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  dataGroupId: oldData_1.dataGroupId,\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n\n            batch.newSeries.push({\n              dataGroupId: newDataGroupId,\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\n\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n\n    if (found) {\n      return i;\n    }\n  }\n}\n\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n\n    if (idx >= 0) {\n      from.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: data,\n        divide: getDivideShapeFromData(data),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\n\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api); // TODO multiple to multiple series.\n\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // TODO transitionOpt was used in an old implementation and can be removed now\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      } // Reset\n\n\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    } // Save all series of current update. Not only the updated one.\n\n\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedDataGroupIds = globalStore.oldDataGroupIds = [];\n    var savedData = globalStore.oldData = [];\n\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData(); // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));\n        savedData.push(data);\n      }\n    }\n  });\n}","map":{"version":3,"names":["SERIES_UNIVERSAL_TRANSITION_PROP","createHashMap","each","map","filter","isArray","extend","applyMorphAnimation","getPathList","Path","initProps","DataDiffer","makeInner","normalizeToArray","warn","getAnimationConfig","getOldStyle","Displayable","DATA_COUNT_THRESHOLD","TRANSITION_NONE","TRANSITION_P2C","TRANSITION_C2P","getUniversalTransitionGlobalStore","getDimension","data","visualDimension","dimensions","i","length","dimInfo","getDimensionInfo","otherDims","getValueByDimension","dataIndex","dimension","dimOrdinalMeta","ordinalMeta","value","get","name","categories","getGroupId","dataGroupId","isChild","groupIdDim","groupId","rawDataItem","getRawDataItem","property","getId","flattenDataDiffItems","list","items","seriesInfo","count","process","env","NODE_ENV","indices","getIndices","push","childGroupId","divide","fadeInElement","newEl","newSeries","newIndex","traverse","el","style","opacity","isFrom","removeEl","parent","computedTransform","getComputedTransform","setLocalTransform","remove","stopAnimation","isGroup","child","animateElementStyles","seriesModel","animationConfig","oldStyle","animateFrom","isAllIdSame","oldDiffItems","newDiffItems","len","oldItem","newItem","transitionBetween","oldList","newList","api","updateMorphingPathProps","from","to","rawFrom","rawTo","animationCfg","hasMorphAnimation","direction","oldGroupIds","oldChildGroupIds","forEach","item","set","newGroupId","newChildGroupId","createKeyGetter","isOld","onlyGetId","diffItem","useId","isElementStillInChart","getItemGraphicEl","id","updateOneToOne","oldIndex","hostModel","oldEl","update","updateManyToOne","oldIndices","newData","oldElsList","idx","updateOneToMany","newIndices","newElsList","newSeris","updateManyToMany","rawIdx","execute","_a","view","getViewOfSeriesModel","isAnimationEnabled","duration","group","animators","getSeriesTransitionKey","series","seriesKey","getModel","convertArraySeriesKeyToString","sort","join","getDivideShapeFromData","findTransitionSeriesBatches","globalStore","params","updateBatches","oldDataMap","oldDataMapForSplit","oldSeries","oldDataGroupId","oldDataGroupIds","oldData","transitionKey","transitionKeyStr","key","checkTransitionSeriesKeyDuplicated","updatedSeries","isUniversalTransitionEnabled","newDataGroupId","getData","oldSeries_1","oldData_1","batch","querySeries","finder","found","seriesIndex","seriesId","transitionSeriesFromOpt","transitionOpt","installUniversalTransition","registers","registerUpdateLifecycle","ecMOdel","seriesTransition","transOpt","ecModel","optionChanged","opt","updateBatches_1","keys","allSeries","getSeries","savedSeries","savedDataGroupIds","savedData"],"sources":["C:/Users/86138/Desktop/软件/room/room-vue/node_modules/echarts/lib/animation/universalTransition.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTransition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\nvar TRANSITION_NONE = 0;\nvar TRANSITION_P2C = 1;\nvar TRANSITION_C2P = 2;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\nfunction getDimension(data, visualDimension) {\n  var dimensions = data.dimensions;\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n    if (dimInfo && dimInfo.otherDims[visualDimension] === 0) {\n      return dimensions[i];\n    }\n  }\n}\n// get value by dimension. (only get value of itemGroupId or childGroupId, so convert it to string)\nfunction getValueByDimension(data, dataIndex, dimension) {\n  var dimInfo = data.getDimensionInfo(dimension);\n  var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n  if (dimInfo) {\n    var value = data.get(dimInfo.name, dataIndex);\n    if (dimOrdinalMeta) {\n      return dimOrdinalMeta.categories[value] || value + '';\n    }\n    return value + '';\n  }\n}\nfunction getGroupId(data, dataIndex, dataGroupId, isChild) {\n  // try to get groupId from encode\n  var visualDimension = isChild ? 'itemChildGroupId' : 'itemGroupId';\n  var groupIdDim = getDimension(data, visualDimension);\n  if (groupIdDim) {\n    var groupId = getValueByDimension(data, dataIndex, groupIdDim);\n    return groupId;\n  }\n  // try to get groupId from raw data item\n  var rawDataItem = data.getRawDataItem(dataIndex);\n  var property = isChild ? 'childGroupId' : 'groupId';\n  if (rawDataItem && rawDataItem[property]) {\n    return rawDataItem[property] + '';\n  }\n  // fallback\n  if (isChild) {\n    return;\n  }\n  // try to use series.dataGroupId as groupId, otherwise use dataItem's id as groupId\n  return dataGroupId || data.getId(dataIndex);\n}\n// flatten all data items from different serieses into one arrary\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n    var dataGroupId = seriesInfo.dataGroupId;\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n      return;\n    }\n    var indices = data.getIndices();\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        data: data,\n        groupId: getGroupId(data, dataIndex, dataGroupId, false),\n        childGroupId: getGroupId(data, dataIndex, dataGroupId, true),\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\nfunction stopAnimation(el) {\n  el.stopAnimation();\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from\n        // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        ? extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n  var hasMorphAnimation = false;\n  /**\n   * With groupId and childGroupId, we can build parent-child relationships between dataItems.\n   * However, we should mind the parent-child \"direction\" between old and new options.\n   *\n   * For example, suppose we have two dataItems from two series.data:\n   *\n   * dataA: [                          dataB: [\n   *   {                                 {\n   *     value: 5,                         value: 3,\n   *     groupId: 'creatures',             groupId: 'animals',\n   *     childGroupId: 'animals'           childGroupId: 'dogs'\n   *   },                                },\n   *   ...                               ...\n   * ]                                 ]\n   *\n   * where dataA is belong to optionA and dataB is belong to optionB.\n   *\n   * When we `setOption(optionB)` from optionA, we choose childGroupId of dataItemA and groupId of\n   * dataItemB as keys so the two keys are matched (both are 'animals'), then universalTransition\n   * will work. This derection is \"parent -> child\".\n   *\n   * If we `setOption(optionA)` from optionB, we also choose groupId of dataItemB and childGroupId\n   * of dataItemA as keys and universalTransition will work. This derection is \"child -> parent\".\n   *\n   * If there is no childGroupId specified, which means no multiLevelDrillDown/Up is needed and no\n   * parent-child relationship exists. This direction is \"none\".\n   *\n   * So we need to know whether to use groupId or childGroupId as the key when we call the keyGetter\n   * functions. Thus, we need to decide the direction first.\n   *\n   * The rule is:\n   *\n   * if (all childGroupIds in oldDiffItems and all groupIds in newDiffItems have common value) {\n   *   direction = 'parent -> child';\n   * } else if (all groupIds in oldDiffItems and all childGroupIds in newDiffItems have common value) {\n   *   direction = 'child -> parent';\n   * } else {\n   *   direction = 'none';\n   * }\n   */\n  var direction = TRANSITION_NONE;\n  // find all groupIds and childGroupIds from oldDiffItems\n  var oldGroupIds = createHashMap();\n  var oldChildGroupIds = createHashMap();\n  oldDiffItems.forEach(function (item) {\n    item.groupId && oldGroupIds.set(item.groupId, true);\n    item.childGroupId && oldChildGroupIds.set(item.childGroupId, true);\n  });\n  // traverse newDiffItems and decide the direction according to the rule\n  for (var i = 0; i < newDiffItems.length; i++) {\n    var newGroupId = newDiffItems[i].groupId;\n    if (oldChildGroupIds.get(newGroupId)) {\n      direction = TRANSITION_P2C;\n      break;\n    }\n    var newChildGroupId = newDiffItems[i].childGroupId;\n    if (newChildGroupId && oldGroupIds.get(newChildGroupId)) {\n      direction = TRANSITION_C2P;\n      break;\n    }\n  }\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex;\n      // TODO if specified dim\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      }\n      if (isOld) {\n        return direction === TRANSITION_P2C ? diffItem.childGroupId : diffItem.groupId;\n      } else {\n        return direction === TRANSITION_C2P ? diffItem.childGroupId : diffItem.groupId;\n      }\n    };\n  }\n  // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel;\n    // TODO Mark this elements is morphed and don't morph them anymore\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex);\n    // Can't handle same elements.\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n    if (\n    // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n      if (oldEl) {\n        stopAnimation(oldEl);\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    }\n    // else keep oldEl leaving animation.\n  }\n\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n    if (newEl) {\n      stopAnimation(newEl);\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    }\n    // else keep oldEl leaving animation.\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    // We can't use the elements that already being morphed\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n      if (oldEl) {\n        stopAnimation(oldEl);\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide,\n        // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    }\n    // else keep oldEl leaving animation.\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n  return seriesKey;\n}\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n  return seriesKey;\n}\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap();\n  // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldDataGroupId = globalStore.oldDataGroupIds[idx];\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, {\n      dataGroupId: oldDataGroupId,\n      data: oldData\n    });\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          key: transitionKeyStr,\n          dataGroupId: oldDataGroupId,\n          data: oldData\n        });\n      });\n    }\n  });\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newDataGroupId = series.get('dataGroupId');\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n      // Only transition between series with same id.\n      var oldData = oldDataMap.get(transitionKeyStr);\n      // string transition key is the best match.\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        }\n        // TODO check if data is same?\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            dataGroupId: oldData.dataGroupId,\n            divide: getDivideShapeFromData(oldData.data),\n            data: oldData.data\n          }],\n          newSeries: [{\n            dataGroupId: newDataGroupId,\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        // e.g. 'female', 'male' -> ['female', 'male']\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n            if (oldData.data) {\n              oldSeries_1.push({\n                dataGroupId: oldData.dataGroupId,\n                divide: getDivideShapeFromData(oldData.data),\n                data: oldData.data\n              });\n            }\n          });\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                dataGroupId: newDataGroupId,\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          // e.g. ['female', 'male'] -> 'female', 'male'\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  dataGroupId: oldData_1.dataGroupId,\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n            batch.newSeries.push({\n              dataGroupId: newDataGroupId,\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n    if (found) {\n      return i;\n    }\n  }\n}\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n    if (idx >= 0) {\n      from.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: data,\n        divide: getDivideShapeFromData(data),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api);\n    // TODO multiple to multiple series.\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // TODO transitionOpt was used in an old implementation and can be removed now\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      }\n      // Reset\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    }\n    // Save all series of current update. Not only the updated one.\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedDataGroupIds = globalStore.oldDataGroupIds = [];\n    var savedData = globalStore.oldData = [];\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData();\n      // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));\n        savedData.push(data);\n      }\n    }\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}